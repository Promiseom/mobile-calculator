package com.aemis.promiseanendah.advancedscientificcalculator.calculators;

import android.content.Context;
import android.content.SharedPreferences;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;

import java.util.ArrayList;
import java.lang.Math;
import aemis.calculator.Mathematics;
import android.widget.EditText;

import com.aemis.promiseanendah.advancedscientificcalculator.MainActivity;
import com.aemis.promiseanendah.advancedscientificcalculator.R;

/**
 * A placeholder fragment containing a simple view.
 * Contains most operations ans stated needed by the all the other calculator fragments
 * Some of the features(functionalities) of this class might not be used by other calculators
 */
public class CalculatorFragment extends Fragment implements View.OnClickListener{

    public static final String TAG = "CalculatorFragment";
    private static final String STANDARD_CALCULATOR_PREF_NAME = "Standard_Calculator_Pref_Name";


    //the following are keys used to store and retrieve data using the Bundle class
    public static final String OPERATOR_KEY = "Operator";
    public static final String OPERAND_KEY = "Operand";
    public static final String TEMPORARY_OPERAND_KEY = "Temp Operand";
    public static final String OPERAND_IS_CLICKED_KEY = "Operand is clicked";
    public static final String RESULT_KEY = "Result";
    public static final String RESULT_TEXT_KEY = "Result Text";
    public static final String OPERATION_TEXT_KEY = "Operation Key";
    public static final String FUNCTION_KEY_CLICKED_LAST = "Function key last";
    public static final String OPERATION_TEXT_BEFORE_FUNCTION_KEY = "Operation Text Before function key";
    public static final String LAST_FUNCTION_OPERATION_KEY = "Last function operation";

    //these are tags used to identify the buttons in the calculator
    public static final String TAG_OPERATORS = "OPERATORS";
    public static final String TAG_FUNCTION_KEYS = "FUNCTION";
    public static final String TAG_NUMERIC_KEYS = "NUMBERS";
    public static final String TAG_OTHER_KEYS = "OTHERS";

    protected EditText operationText, resultText;
    private double result, operand;

    /*tempOperand - this number is converted to an operand and assigned to operand when an operator or a function key is pressed
    *previousTextBeforeFunction is the previous operation text before function keys were pressed
    *latestFunctionOperation is the operation generated by the last function key
    *For example
    *You have the operation 9 x 5 + 2 + , and a new operand "9" has been entered from the keyboard
    *When the function SQR has been called on the operand, the following are taken into account,
    * The previousOperationBeforeFunctionKey = 9 x 5 + 2 + , and the latestFunctionOperation = SQR(9)
    * The final operation is expressed as appending the latestOperationFunction to the previousOperationBeforeFunction
    * When another function is pressed successively with no new operand entry by the user the new function operation is carried out
    * on the latestFunctionOperation, taking it as the new operand, the same final result is the result of the appending repeated.
    * Leading to something like 9 x 5 + 2 +
    * The newly created operation which is the result of the appending is finally taken as the previousOperationBeforeFunctionKey when other
    * key breaks the loop(operand or operator key).
    */
    private String tempOperand, operator, operationTextBeforeFunctionKey = "null", latestFunctionOperation = "";

    /*The opposite of the operand key is the operator key
    * When the click of an operator can change the value of operandKeyLast,
    * There are 2 states of the standard calculator,
    * 1. When creating an operand, this is when the operand keys are being clicked and here each digit gets concatenated to the previous one
    * 2. The other states is when operations are being carried out on the created operands created.
    * When creating a new operand, the previously created operand has to be cleared so the new one can be created, to do this the program has to know
    * that it is time to clear the previously created operand.
    *
    * When a function key is clicked, an operation is carried out on the current operand yielding another, the next digit input from the user means
    * another operand is to created, if this digit comes immediately after the function key, every thing is cleared, both operations and operands,
    * so a new operand can be created.
    * After an operator has been clicked, a new operand needs to be created, and when the equals button is clicked, a new operand needs
    * to be created by the next digit from the user.
    *
    * When an operator button is clicked after having not having clicked another key (function, operand or equal to buttons), the latest operator
    * replaces the older one both in operation and variable.
    */
    private boolean operandKeyLast, operatorKeyLast, functionKeyLast, equalsButtonClicked;
    private String lastClickedButtonType;
    protected ArrayList<Button> numberKeys = new ArrayList<>();
    protected Button btnFunctionSquareRoot, btnFunctionPercentage, btnFunctionInverse;
    protected Button btnOperatorPlus, btnOperatorMinus, btnOperatorMultiplication, btnOperatorDivision, btnOperatorExponent;
    protected Button btnDelete, btnCancel, btnCancelResult, btnEquals, btnPlusMinus, btnDot;

    public CalculatorFragment() {
        this.result = this.operand = 0;
        this.operator = "+";
        this.lastClickedButtonType = "none";
        this.operandKeyLast = this.operatorKeyLast = this.functionKeyLast = this.equalsButtonClicked = false;
        this.tempOperand = "0";
        Log.d(TAG, "Constructor called");
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
    {
        return inflater.inflate(R.layout.standard_calculator_content, container, false);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState)
    {
        super.onActivityCreated(savedInstanceState);
        ((MainActivity)getHost()).getSupportActionBar().setTitle("Standard");

        View view = null;

        //restore application state from saved instance bundle
        if(savedInstanceState != null)
        {
            this.result = savedInstanceState.getFloat(RESULT_KEY, 0);
            this.operand = savedInstanceState.getFloat(OPERAND_KEY, 0);
            this.operator = savedInstanceState.getString(OPERATOR_KEY, "+");
            this.operandKeyLast = savedInstanceState.getBoolean(OPERAND_IS_CLICKED_KEY, false);
            this.tempOperand = savedInstanceState.getString(TEMPORARY_OPERAND_KEY, "0");
            this.operationTextBeforeFunctionKey = savedInstanceState.getString(OPERATION_TEXT_BEFORE_FUNCTION_KEY, "");
            this.latestFunctionOperation = savedInstanceState.getString(LAST_FUNCTION_OPERATION_KEY, "");
            this.functionKeyLast = savedInstanceState.getBoolean(FUNCTION_KEY_CLICKED_LAST, false);

            Log.d(TAG, "Restoring the fragment state");
        }else
        {
            //restore from sharedPreferences
            restoreFragmentState();
        }
        try
        {
            view = getView();

            //get the primary textViews
            this.operationText = (EditText) view.findViewById(R.id.txt_operation);
            //this.operationText.setInputType(InputType.TYPE_TEXT_FLAG_MULTI_LINE);
            //this.operationText.setHorizontallyScrolling(true);
            //this.operationText.setHorizontalScrollBarEnabled(true);
            this.resultText = (EditText) view.findViewById(R.id.txt_operation_result);
            this.operationText.setInputType(View.LAYER_TYPE_NONE);
            this.resultText.setInputType(View.LAYER_TYPE_NONE);
            this.resultText.setOnLongClickListener(new View.OnLongClickListener()
            {
               @Override
               public boolean onLongClick(View v)
               {
                   EditText editor = (EditText)v;
                   ((MainActivity)getActivity()).copyContentToClipboard(editor.getText());
                   return false;
               }
            });

            this.resultText.setMaxLines(1);
            this.resultText.setText(this.tempOperand);

            //add the number key buttons
            this.numberKeys.add((Button) view.findViewById(R.id.btn_0));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_1));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_2));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_3));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_4));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_5));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_6));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_7));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_8));
            this.numberKeys.add((Button) view.findViewById(R.id.btn_9));

            //set listeners for all the buttons
            for (Button btn : this.numberKeys) {
                btn.setTag(TAG_NUMERIC_KEYS);
                btn.setOnClickListener(this);
            }

            //get the function keys
            this.btnFunctionSquareRoot = (Button) view.findViewById(R.id.btn_function_square_root);
            this.btnFunctionSquareRoot.setOnClickListener(this);
            this.btnFunctionSquareRoot.setTag(TAG_FUNCTION_KEYS);

            this.btnFunctionInverse = (Button) view.findViewById(R.id.btn_function_inverse);
            this.btnFunctionInverse.setOnClickListener(this);
            this.btnFunctionInverse.setTag(TAG_FUNCTION_KEYS);

            this.btnFunctionPercentage = (Button) view.findViewById(R.id.btn_function_percent);
            this.btnFunctionPercentage.setOnClickListener(this);
            this.btnFunctionPercentage.setTag(TAG_FUNCTION_KEYS);

            //operator keys
            this.btnOperatorExponent = (Button) view.findViewById(R.id.btn_function_exponent);
            this.btnOperatorExponent.setOnClickListener(this);
            this.btnOperatorExponent.setTag(TAG_OPERATORS);

            this.btnOperatorDivision = (Button) view.findViewById(R.id.btn_operator_division);
            this.btnOperatorDivision.setOnClickListener(this);
            this.btnOperatorDivision.setTag(TAG_OPERATORS);

            this.btnOperatorMultiplication = (Button) view.findViewById(R.id.btn_operator_multiplication);
            this.btnOperatorMultiplication.setOnClickListener(this);
            this.btnOperatorMultiplication.setTag(TAG_OPERATORS);

            this.btnOperatorPlus = (Button) view.findViewById(R.id.btn_operator_plus);
            this.btnOperatorPlus.setOnClickListener(this);
            this.btnOperatorPlus.setTag(TAG_OPERATORS);

            this.btnOperatorMinus = (Button) view.findViewById(R.id.btn_operator_minus);
            this.btnOperatorMinus.setOnClickListener(this);
            this.btnOperatorMinus.setTag(TAG_OPERATORS);

            //other keys
            this.btnDelete = (Button) view.findViewById(R.id.btn_backspace);
            this.btnDelete.setOnClickListener(this);
            this.btnDelete.setTag(TAG_NUMERIC_KEYS);

            this.btnCancel = (Button) view.findViewById(R.id.btn_cancel);
            this.btnCancel.setOnClickListener(this);
            this.btnCancel.setTag(TAG_OTHER_KEYS);

            this.btnCancelResult = (Button) view.findViewById(R.id.btn_cancel_result);
            this.btnCancelResult.setOnClickListener(this);
            this.btnCancelResult.setTag(TAG_NUMERIC_KEYS);

            this.btnPlusMinus = (Button) view.findViewById(R.id.btn_plus_minus);
            this.btnPlusMinus.setOnClickListener(this);
            this.btnPlusMinus.setTag(TAG_NUMERIC_KEYS);

            this.btnDot = (Button) view.findViewById(R.id.btn_dot);
            this.btnDot.setOnClickListener(this);
            this.btnDot.setTag(TAG_NUMERIC_KEYS);

            this.btnEquals = (Button) view.findViewById(R.id.btn_equals);
            this.btnEquals.setOnClickListener(this);
            this.btnEquals.setTag(TAG_OTHER_KEYS);

        }
        catch(NullPointerException e)
        {
            //something went wrong
        }
    }

    @Override
    public void onViewStateRestored(@Nullable Bundle savedInstanceState) {
        super.onViewStateRestored(savedInstanceState);
        if(savedInstanceState != null)
        {
            this.operationText.setText(savedInstanceState.getString(OPERATION_TEXT_KEY, ""));
            this.resultText.setText(savedInstanceState.getString(RESULT_TEXT_KEY, "0"));
            Log.d(TAG, "View state been from savedInstance");
        }else
        {
            //restore data from sharedPreferences
            SharedPreferences pref = getActivity().getSharedPreferences(STANDARD_CALCULATOR_PREF_NAME, Context.MODE_PRIVATE);
            this.operationText.setText(pref.getString(OPERATION_TEXT_KEY, ""));
            this.resultText.setText(pref.getString(RESULT_TEXT_KEY, "0"));
        }
    }

    @Override
    public void onClick(View view)
    {
        Button clickedButton = (Button)view;
        Log.d(TAG, clickedButton.getText() + " clicked");

        switch((String)view.getTag())
        {
            case TAG_FUNCTION_KEYS:
                onFunctionKeyClicked(clickedButton);
                this.functionKeyLast = true;
                this.lastClickedButtonType = TAG_FUNCTION_KEYS;
                this.equalsButtonClicked = this.operandKeyLast = this.operatorKeyLast = false;
                break;
            case TAG_NUMERIC_KEYS:
                onOperandKeyClicked(clickedButton);
                this.operandKeyLast = true;
                this.lastClickedButtonType = TAG_NUMERIC_KEYS;
                this.functionKeyLast = this.equalsButtonClicked = this.operatorKeyLast = false;
                this.operationTextBeforeFunctionKey = "null";
                this.latestFunctionOperation = "";
                break;
            case TAG_OPERATORS:
                if(clickedButton == btnOperatorExponent)
                {
                    clickedButton.setText("^");
                    onOperatorClicked(clickedButton);
                    clickedButton.setText("x^");
                }else
                {
                    onOperatorClicked(clickedButton);
                }
                this.operatorKeyLast = true;
                this.lastClickedButtonType = TAG_OPERATORS;
                this.operandKeyLast = this.functionKeyLast = this.equalsButtonClicked = false;
                this.operationTextBeforeFunctionKey = "null";
                this.latestFunctionOperation = "";
                break;
            case TAG_OTHER_KEYS:
                onOtherKeyClicked(clickedButton);
                this.functionKeyLast = false;
                this.lastClickedButtonType = TAG_OTHER_KEYS;
                this.operationTextBeforeFunctionKey = "null";
                this.latestFunctionOperation = "";
                break;
        }
        this.operationText.setSelection(this.operationText.length());
        this.resultText.setSelection(this.resultText.length());
    }

    //handle operands
    //any key that modifies an operand either adding to it or deleting from it is a operand key
    public void onOperandKeyClicked(Button button)
    {
        String currentContent = this.resultText.getText().toString();

        //check if they're operand modifies
        switch(button.getId())
        {
            case R.id.btn_dot:
                ///////////////////////////////////////////////////
                if(this.functionKeyLast || this.equalsButtonClicked)
                {
                    this.resultText.setText("0");
                    this.operationText.setText("");
                }else {
                    if(currentContent.contains("."))
                    {
                        return;
                    }
                    this.resultText.setText(this.resultText.getText().toString().concat(button.getText().toString()));
                }
                //////////////////////////////////////////////////
                break;

            case R.id.btn_backspace:
                if(currentContent.equals("0")) {
                    break; //terminate this case
                }
                //remove one digit from the right
                this.resultText.setText(currentContent.substring(0, currentContent.length() - 1));
                if (this.resultText.getText().length() == 0 || this.resultText.getText().toString().equals("-")) {
                    this.resultText.setText("0");
                }
                break;

            case R.id.btn_cancel_result:
                /*if(!this.operationTextBeforeFunctionKey.equals("null"))
                {
                    //a function key was the last button clicked
                 this.operationText.setText(this.operationTextBeforeFunctionKey);
                }*/
                this.resultText.setText("0");
                break;

            case R.id.btn_plus_minus:
                String resultContent = this.resultText.getText().toString();

                if(resultContent.charAt(0) == '-')
                {
                    resultContent = resultContent.substring(1, resultContent.length());
                }else
                {
                    resultContent = "-" + resultContent;
                }
                this.resultText.setText(resultContent);
                /////////////////////////////////////////////
                if(this.functionKeyLast || this.equalsButtonClicked)
                {
                    this.resultText.setText("0");
                    this.operationText.setText("");
                }
                ////////////////////////////////////////////
                break;
            default:
                //if they're numeric keys
                //if the last key pressed is either a function key or an operator key then create a new operand altogether
                if(this.functionKeyLast || this.equalsButtonClicked)
                {
                    this.resultText.setText("");
                    this.operationText.setText("");
                }
                if(this.resultText.getText().toString().equals("0") || !this.operandKeyLast)
                {
                    this.resultText.setText("");
                }else if(this.resultText.getText().toString().equals("Infinity"))
                {
                    this.resultText.setText("");
                    this.result = this.operand = 0;
                    this.operator = "+";
                    this.operandKeyLast = false;
                    this.operationText.setText("");
                }
                this.resultText.setText(this.resultText.getText().toString().concat(button.getText().toString()));
        }

    }

    //handle operators
    public void onOperatorClicked(Button button)
    {
        //if the last click was an operator change it to the new operator
        if(this.operatorKeyLast && this.operationText.getText().toString().length() > 0)
        {
            Log.d(TAG, "No new operand has been created after the last operator click");

            String tempContent = this.operationText.getText().toString();
            tempContent = tempContent.substring(0, tempContent.length() - 2);
            tempContent = tempContent.concat(button.getText().toString() + " ");
            this.operationText.setText(tempContent);
            this.operator = button.getText().toString();
            //do not perform any calculations, just update the operator to the latest one
            return;
        }else if(!this.functionKeyLast)
        {
            //when the function key is clicked the operation is concatenated to the operation text field
            //there will be no need sending the result to the operation field again
            this.operationText.setText(this.operationText.getText().toString().concat(this.resultText.getText() + " " + button.getText().toString() + " "));
        }else
        {
            this.operationText.setText(this.operationText.getText().toString().concat(" " + button.getText().toString() + " "));
        }

        try
        {
            this.operand = Double.parseDouble(this.resultText.getText().toString());
        }catch(NumberFormatException arg)
        {
            Log.d(TAG, "Cannot convert " + this.resultText.getText().toString());
        }

        this.result = Mathematics.calculate(this.result, this.operator, this.operand);
        if(Mathematics.canRepresentAsInteger(this.result))
        {
            Log.d(TAG, "Setting number as integer");
            this.resultText.setText(Integer.toString((int)this.result));  //check
        }else
        {
            Log.d(TAG, "Setting number as double");
            this.resultText.setText(Double.toString(this.result));  //check
        }
        Log.d(TAG, "The operator is " + button.getText().toString());
        this.operator = button.getText().toString();
    }

    //handle function keys
    public void onFunctionKeyClicked(Button button)
    {
        if(this.operationTextBeforeFunctionKey.equals("null"))
        {
            this.operationTextBeforeFunctionKey = this.operationText.getText().toString();
            //Log.d(TAG, "TempOperationText:  " + tempOperationText);
            //this.operationText.setText(this.operationText.getText().toString().concat(" SQR(" + tempOperationText +") "));
        }

        double finalResult = 0;  //final result of the function operation

        switch(button.getId())
        {
            case R.id.btn_function_percent:
                finalResult = Mathematics.percentage(Double.parseDouble(this.resultText.getText().toString()));
                this.latestFunctionOperation = Double.toString(finalResult);
                break;
            case R.id.btn_function_square_root:
                finalResult = Math.sqrt(Double.parseDouble(this.resultText.getText().toString()));
                if(this.latestFunctionOperation.equals("")) {

                    this.latestFunctionOperation = "SQR(" + this.resultText.getText().toString() + ")";
                }else
                {
                    this.latestFunctionOperation = "SQR(" + this.latestFunctionOperation + ")";
                }
                break;
            case R.id.btn_function_inverse:
                finalResult = 1 / (Double.parseDouble(this.resultText.getText().toString()));
                if(this.latestFunctionOperation.equals("")) {
                    this.latestFunctionOperation = "1/(" + this.resultText.getText().toString() + ")";
                }else
                {
                    this.latestFunctionOperation = " 1/(" + this.latestFunctionOperation + ")";
                }
                break;
        }

        String finalOperationText = (this.operationTextBeforeFunctionKey + this.latestFunctionOperation);
        this.operationText.setText(finalOperationText);
        if(Mathematics.canRepresentAsInteger(finalResult))
        {
            this.resultText.setText(Integer.toString((int)finalResult));
        }else
        {
            this.resultText.setText(Double.toString(finalResult));  //check
        }
    }

    //handle other keys
    public void onOtherKeyClicked(Button button) {
        String currentContent = this.resultText.getText().toString();
        switch (button.getId()) {
            case R.id.btn_cancel:
                this.result = this.operand = 0;
                this.operator = "+";
                this.operandKeyLast = false;
                this.operationText.setText("");
                this.resultText.setText("0");
                //Toast.makeText(getContext(), "All Cleared!", Toast.LENGTH_SHORT).show();
                break;

            case R.id.btn_equals:
                this.operationText.setText("");
                try
                {
                    this.operand = Double.parseDouble(this.resultText.getText().toString());
                } catch (NumberFormatException arg)
                {
                    Log.d(TAG, "Cannot convert " + this.resultText.getText().toString());
                }
                this.result = Mathematics.calculate(this.result, this.operator, this.operand);
                this.operand = 0;
                this.operandKeyLast = true;
                this.operator = "+";
                if(Mathematics.canRepresentAsInteger(this.result))
                {
                    this.resultText.setText(Integer.toString((int)this.result)); //check
                }else
                {
                    this.resultText.setText(Double.toString(this.result)); //check
                }
                //clear the result to avoid it interfering with calculations after clicking this button for the result
                
                this.result = this.operand = 0;
                //the functionKeyLast flag has already been set to false
                this.operatorKeyLast = this.operandKeyLast = false;
                this.equalsButtonClicked = true;
                break;
        }
    }

    @Override
    public void onSaveInstanceState(Bundle instanceState) {
        super.onSaveInstanceState(instanceState);
        //save result
        instanceState.putFloat(RESULT_KEY, (float)this.result);  //may might be lost
        //operand
        instanceState.putFloat(OPERAND_KEY, (float)this.operand);//may might be lost
        //operator
        instanceState.putString(OPERATOR_KEY, this.operator);
        //operandsClicked
        instanceState.putBoolean(OPERAND_IS_CLICKED_KEY, this.operandKeyLast);
        instanceState.putBoolean(FUNCTION_KEY_CLICKED_LAST, this.functionKeyLast);
        //tempOperand
        instanceState.putString(TEMPORARY_OPERAND_KEY, this.tempOperand);
        //current content of the screen
        instanceState.putString(OPERATION_TEXT_KEY, this.operationText.getText().toString());
        instanceState.putString(RESULT_TEXT_KEY, this.resultText.getText().toString());

        instanceState.putString(OPERATION_TEXT_BEFORE_FUNCTION_KEY, this.operationTextBeforeFunctionKey);
        instanceState.putString(LAST_FUNCTION_OPERATION_KEY, this.latestFunctionOperation);
    }

    @Override
    public void onStop()
    {
        super.onStop();
        saveFragmentInstanceState();
    }

    @Override
    public void onDestroy()
    {
        super.onDestroy();
    }

    private void saveFragmentInstanceState()
    {
        SharedPreferences pref = getActivity().getSharedPreferences(STANDARD_CALCULATOR_PREF_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor prefEditor = pref.edit();

        //save result
        prefEditor.putFloat(RESULT_KEY, (float)this.result);  //may might be lost
        //operand
        prefEditor.putFloat(OPERAND_KEY, (float)this.operand);//may might be lost
        //operator
        prefEditor.putString(OPERATOR_KEY, this.operator);
        //operandsClicked
        prefEditor.putBoolean(OPERAND_IS_CLICKED_KEY, this.operandKeyLast);
        prefEditor.putBoolean(FUNCTION_KEY_CLICKED_LAST, this.functionKeyLast);
        //tempOperand
        prefEditor.putString(TEMPORARY_OPERAND_KEY, this.tempOperand);
        //current content of the screen
        prefEditor.putString(OPERATION_TEXT_KEY, this.operationText.getText().toString());
        prefEditor.putString(RESULT_TEXT_KEY, this.resultText.getText().toString());

        prefEditor.putString(OPERATION_TEXT_BEFORE_FUNCTION_KEY, this.operationTextBeforeFunctionKey);
        prefEditor.putString(LAST_FUNCTION_OPERATION_KEY, this.latestFunctionOperation);

        Log.d(TAG, "Saving data to shared preferences");
        prefEditor.apply();
    }

    private void restoreFragmentState()
    {
        SharedPreferences pref = getActivity().getSharedPreferences(STANDARD_CALCULATOR_PREF_NAME, Context.MODE_PRIVATE);

        this.result = pref.getFloat(RESULT_KEY, 0);
        this.operand = pref.getFloat(OPERAND_KEY, 0);
        this.operator = pref.getString(OPERATOR_KEY, "+");
        this.operandKeyLast = pref.getBoolean(OPERAND_IS_CLICKED_KEY, false);
        this.tempOperand = pref.getString(TEMPORARY_OPERAND_KEY, "0");
        this.operationTextBeforeFunctionKey = pref.getString(OPERATION_TEXT_BEFORE_FUNCTION_KEY, "");
        this.latestFunctionOperation = pref.getString(LAST_FUNCTION_OPERATION_KEY, "");
        this.functionKeyLast = pref.getBoolean(FUNCTION_KEY_CLICKED_LAST, false);

        Log.d(TAG, "Restoring application data from shared preferences");
    }
}
